## ✅  Step3 카드덱 구현하고 테스트하기
### **🧑🏼‍💻 작업 목록**   
- [x]  Step3 카드덱 구현하고 테스트하기
  - [x]  구조체와 클래스의 차이 학습 및 속성 변화시 어떤 변화가 있는지 확인
  - [x]  참조 접근자를 활용해서 정보를 감추고 메소드 인터페이스를 통해 접근하는 방식 학습
  - [x]  클래스 메모리 관리 방식에 대해 학습
  - [x]  reset()할 때 이전에 만든 카드 객체는 어떻게 되는지 설명할  수 있어야한다.
  - [x]  개발 환경에서 제공하는 메모리를 분석하는 디버깅 도구 확습   
  
### 🟢 ARC (Automatic Reference Counting) 자동 참조 카운팅
참조 타입은 하나의 인스턴스가 참조를 통해 여러곳에서 접근하기 때문에 언제 메모리에서 해제되는지가 중요한 문제이다.   
해제되지 않으면 한정적인 메모리 자원을 낭비하게 되며, 이는 성능의 저하로 이어지게 된다.

- ARC가 관리해주는 참조 횟수 계산(Reference Counting)은 참조 타입인 클래스의 인스턴스에만 적용된다.   
구조체나 열거형은 다른 곳에서 참조하지 않기 때문에 ARC로 관리할 필요가 없다.   

| 메모리 관리 기법 | ARC | 가비지 컬렉션 |
| --- | --- | --- |
| ⭐️ 참조 카운팅 시점 | 컴파일 시 | 프로그램 동작 중 |
| 장점 | 컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있어서 인스턴스가 언제 메모리에서 해제될 지 예측할 수 있다. 컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있어서 메모리 관리를 위한 시스템 자원을 추가할 필요가 없다. | 상호 참조 상황 등의 복잡한 상황에서도 인스턴스를 해제할 수 있는 가능성이 더 높다.   특별히 규칙에 신경 쓸 필요가 없다. |
| 단점 | ARC의 작동 규칙을 모르고 사용하면 인스턴스가 메모리에서 영원히 해제되지 않을 가능성이 있다. | 프로그램 동작 외에 메모리 감시를 위한 추가 자원이 필요하므로 한정적인 자원 환경에서는 성능 저하가 발생할 수 있다.   명확한 규칙이 없기 때문에 인스턴스가 정확히 언제 메모리에서 해제될지 예측하기 어렵다. | ARC는 컴파일과 동시에 인스턴스를 메모리에서 해제하는 시점이 결정한다. 클래스의 인스턴스를 생성할 때마다 ARC는 그 인스턴스에 대한 정보를 저장하기 위한 메모리 공간을 따로 또 할당한다.   메모리 공간에 저장되는 항목 인스턴스의 타입 정보 인스턴스와 관련된 저장 프로퍼티의 값 등 이후 인스턴스가 더 이상 필요 없는 상태가 되면 인스턴스가 차지하던 메모리 공간을 다른 용도로 활용할 수 있도록 ARC가 메모리에서 인스턴스를 없앤다.

---
### ✔️ 강한 참조 (Strong Reference)

- 인스턴스는 참조 횟수가 ‘0’이 되는 순간 메모리에서 해제되는데, 인스턴스를 다른 인스턴스의 프로퍼티나   
변수, 상수 등에 할당할 때 강한 참조를 사용하면 참조 횟수가 1 증가한다.   
- 강한 참조를 사용하는 프로퍼티, 변수, 상수 등에 nil을 할당해주면 원래 자신에게 할당되어 있던 인스턴스의   
참조 횟수가 1 감소한다.   
- **참조의 기본은 ‘강한 참조’ 이므로 클래스 타입의 프로퍼티, 변수, 상수 등을 선언할 때 별도의 식별자를 명시하지 않으면 강한 참조를 한다.**   
- ⚠️  인스턴스끼리 서로가 서로를 강한 참조할 때를 대표적인 ‘강한참조의 순환(Strong Reference Cycle)’이라고 한다.   
    - **클로저가 인스턴스의 프로퍼티일 때나, 클로저의 값 획득 특성 때문에 발생**한다.   
    Why? 클로저가 클래스와 같은 참조 타입이기 때문!   
    - 클로저를 클래스 인스턴스의 프로퍼티로 할당하면 클로저의 참조가 할당된다.   
    이때, **참조 타입과 참조 타입이 서로 강한참조를 하기 때문에 순환문제가 발생**한다.   
    Solution? 클로저의 획득목록을 통해 해결할 수 있다!   

### ✔️ 약한 참조 (Weak Reference)

- 약한참조는 강한참조와 달리 **자신이 참조하는 인스턴스의 참조 횟수를 증가시키지않는다.**   
- **참조타입의 프로퍼티나 변수의 선언 앞에 weak 키워드**를 써주면 약한참조를한다.   
- 자신이 참조하는 인스턴스가 메모리에서 해제될 수도 있다는 것을 예상할 수 있어야한다.   

 🤔 **약한참조와 상수, 옵셔널**   

- 약한참조는 상수에서 쓰일 수 없다!   
    - 자신이 참조하던 인스턴스가 메모리에서 해제된다면 **nil이 할당될 수 있어야하기 때문**   
- **자신의 값을 변경할 수 있는 ‘변수’로 선언**해야한다.   
- nil이 할당될 수 있어야 하므로 **약한참조는 항상 옵셔널**이어야한다.   
- 인스턴스가 메모리에서 해제될 때, 자신의 프로퍼티가 강한참조를 하던 인스턴스의 참조 횟수를 1 감소시킨다는 것을 알 수 있다.   
- 자신이 참조하는 인스턴스가 메모리에서 해제되면 자동으로 nil을 할당한다.   

### ✔️  미소유 참조 (Unowned Reference)   
- 인스턴스의 참조 횟수를 증가시키지 않는다. (Weak와 동일)
- 자신이 참조하는 인스턴스가 항상 메모리에 존재할 것이라는 전제를 기반으로 동작한다.   
**즉, 자심이 참조하는 인스턴스가 메모리에서 해제되더라도 스스로 nil을 할당해주지 않는다는 뜻!**
- 참조하는 동안 해당 인스턴스가 메모리에서 해제되지 않으리라는 확신이 있을 때만 사용
- 참조 타입의 프로퍼티나 변수 앞에 unowned 키워드 사용

---
### 🔴 메모리 분석 도구 - 수업자료 확인

- Instruments는 강력하고 유연한 성능 분석 및 테스트도구로서 Xcode tool 집합의 일부이다.   
참고사이트:   
[[iOS - Xcode] Memory Leak, strong Reference, cycle 확인 방법 (with Instruments)](https://ios-development.tistory.com/604)   
[Xcode ) About Instruments](https://zeddios.tistory.com/522)   
[모든 iOS 개발자가 Instruments에서해야 할 일](https://gist.github.com/HwangByungJo/f0ad11feb33df8b5c44e1a85d95e1a0d)

---
### 🟢 참조 접근자 (Access Control)
[Swift Syntax](https://www.notion.so/Swift-Syntax-3ea1cd0b217f46cb9094b7e0f773f541)

---